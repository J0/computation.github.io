<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome to NUS Distributed Systems DYOM! on 6.824 DYOM</title><link>https://nusdistsys.github.io/</link><description>Recent content in Welcome to NUS Distributed Systems DYOM! on 6.824 DYOM</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 21 Jan 2020 22:17:51 +0800</lastBuildDate><atom:link href="https://nusdistsys.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Fault-Tolerant Virtual Machines</title><link>https://nusdistsys.github.io/notes/ftvm/</link><pubDate>Thu, 23 Jan 2020 16:23:37 +0800</pubDate><guid>https://nusdistsys.github.io/notes/ftvm/</guid><description>Why use VMs? Insert some answer here
What does it mean to have difficulties in ensuring deterministic execution of physical server (esp as frequencies increase?) Deterministic Replay implementation Non-deterministic events, non-deterministic operations (virtual interrupts, clock cycle counters respectively) Events - remember which instruction at which they occur at Operations: &amp;ldquo;sufficient information&amp;rdquo; is kept about them - such as? remember what they're undefined for and checking for that condition?</description></item><item><title>RPC</title><link>https://nusdistsys.github.io/notes/rpc/</link><pubDate>Wed, 22 Jan 2020 15:12:27 +0800</pubDate><guid>https://nusdistsys.github.io/notes/rpc/</guid><description>What's an RPC?
It is a model of programming. Under the RPC model, requests are location transparent &amp;ndash; a request to a remote network looks the same as calling a function within the same process.
RPCs are best effort.
Helpful Links
[Reasons to choose RPC over REST API] (https://github.com/donnemartin/system-design-primer#remote-procedure-call-rpc)
More reasons to prefer rest over RPC</description></item><item><title>GFS</title><link>https://nusdistsys.github.io/notes/gfs/</link><pubDate>Wed, 22 Jan 2020 12:04:06 +0800</pubDate><guid>https://nusdistsys.github.io/notes/gfs/</guid><description>Goals for GFS High probability of component failures - requirement to detect and recover promptly from such failures. Common case: a lot of large files, (small files also supported, but not optimised) Support for large streaming reads as well as small random reads Large appends the common use case (to be optimised for this) Atomicity for concurrent appends, with minimal synchronisation overhead High bandwidth over low latency - what does this mean?</description></item></channel></rss>