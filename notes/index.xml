<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on 6.824 DYOM</title><link>https://nusdistsys.github.io/site/notes/</link><description>Recent content in Notes on 6.824 DYOM</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 22 Jan 2020 15:12:27 +0800</lastBuildDate><atom:link href="https://nusdistsys.github.io/site/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>RPC</title><link>https://nusdistsys.github.io/site/notes/rpc/</link><pubDate>Wed, 22 Jan 2020 15:12:27 +0800</pubDate><guid>https://nusdistsys.github.io/site/notes/rpc/</guid><description>Choosing RPC over REST API: [https://github.com/donnemartin/system-design-primer#remote-procedure-call-rpc]
Operation-oriented vs Resource-oriented [https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/#comparing-rpcs-and-rests-requests-styles]
Best Effort</description></item><item><title>GFS</title><link>https://nusdistsys.github.io/site/notes/gfs/</link><pubDate>Wed, 22 Jan 2020 12:04:06 +0800</pubDate><guid>https://nusdistsys.github.io/site/notes/gfs/</guid><description>Goals for GFS High probability of component failures - requirement to detect and recover promptly from such failures. Common case: a lot of large files, (small files also supported, but not optimised) Support for large streaming reads as well as small random reads Large appends the common use case (to be optimised for this) Atomicity for concurrent appends, with minimal synchronisation overhead High bandwidth over low latency - what does this mean?</description></item></channel></rss>